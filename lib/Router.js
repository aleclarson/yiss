// Generated by CoffeeScript 2.3.0
var BREAK, PathMatcher, Pattern, Route, Router, assertValid, configTypes, matchAll, noop, valido;

PathMatcher = require('./PathMatcher');

assertValid = require('assertValid');

valido = require('valido');

Route = require('./Route');

noop = require('noop');

matchAll = /./;

BREAK = Symbol();

Pattern = valido.get('string|regexp?');

configTypes = valido({
  name: 'string?',
  prefix: 'string?'
});

Router = class Router {
  constructor(config = {}) {
    var prefix;
    assertValid(config, configTypes);
    if (config.name) {
      this.name = config.name;
    }
    if (prefix = config.prefix) {
      if (!/^\/.+\/$/.test(prefix)) {
        throw Error('`prefix` must begin and end with /');
      }
      this.prefix = prefix;
      this._prefixRE = new RegExp('^' + prefix);
    } else {
      this.prefix = '/';
      this._prefixRE = matchAll;
    }
    this._routes = [];
    this._matcher = noop.true;
    this._blacklist = noop.false;
    this;
  }

  match(path) {
    if (this._matcher !== noop.true) {
      throw Error('The matcher is already set');
    }
    this._matcher = typeof path === 'function' ? path : PathMatcher.create(path);
    return this;
  }

  blacklist(fn) {
    if (this._blacklist !== noop.false) {
      throw Error('The blacklist is already set');
    }
    assertValid(fn, 'function');
    this._blacklist = fn;
    return this;
  }

  listen(arg) {
    var fn, path, route, verb;
    // Both verb and path are omitted.
    if (arguments.length === 1) {
      assertValid(arg, ['function', Route, Router]);
      this._routes.push(arg);
      return this;
    }
    // The verb and path both exist.
    if (arguments.length === 3) {
      [verb, path, fn] = arguments;
    // The verb or path has been omitted.
    } else if (typeof arguments[0] === 'string') {
      if (/^[A-Z\|]$/.test(arguments[0])) {
        [path, fn] = arguments;
      } else {
        [verb, fn] = arguments;
      }
    // Regular expressions can be used for both verb and path.
    } else if (arguments[0] instanceof RegExp) {
      if (/^[A-Z\|]$/.test(arguments[0])) {
        [path, fn] = arguments;
      } else {
        [verb, fn] = arguments;
      }
    }
    assertValid(verb, Pattern);
    assertValid(path, Pattern);
    assertValid(fn, 'function');
    route = new Route({verb});
    if (path) {
      route.match(path, fn);
    } else {
      route._responder = fn;
    }
    this._routes.push(route);
    return route;
  }

  extend(prefix, plugins) {
    var i, len, plugin, router;
    if (arguments.length === 1) {
      plugins = prefix;
      prefix = '';
    }
    if (Array.isArray(plugins)) {
      for (i = 0, len = plugins.length; i < len; i++) {
        plugin = plugins[i];
        this.extend(prefix, plugin);
      }
    } else {
      assertValid(plugins, 'function');
      plugins.call(router = new Router({prefix}));
      this._routes.push(router);
    }
    return this;
  }

  bind() {
    return this._exec.bind(this);
  }

  _match(req, path) {
    if (this._prefixRE.test(path)) {
      return this._matcher(req, path);
    }
  }

  async _exec(req, res) {
    var i, isFunction, len, next, path, prefix, ref, route, val;
    ({prefix} = this);
    if (req.prefix) {
      prefix = req.prefix + prefix.slice(1);
    }
    ({path} = req);
    if (prefix !== '/') {
      req.prefix = prefix;
      path = path.slice(prefix.length - 1);
    }
    if (val = this._blacklist(req, path)) {
      if (val !== true) {
        return val;
      }
      return 403;
    }
    ({next} = req);
    req.next = noop;
    req.BREAK = BREAK;
    ref = this._routes;
    for (i = 0, len = ref.length; i < len; i++) {
      route = ref[i];
      if (!(isFunction = typeof route === 'function')) {
        if (!route._match(req, path)) {
          continue;
        }
      }
      if (isFunction) {
        val = (await route(req, res));
      } else {
        val = (await route._exec(req, res));
      }
      if (val || res.headersSent) {
        break;
      }
    }
    req.next = next;
    if (val !== BREAK) {
      return val;
    }
  }

};

module.exports = Router;

// Verb shortcuts
['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD'].forEach(function(verb) {
  Router.prototype[verb] = function() {
    return this.listen(verb, ...arguments);
  };
});

//# sourceMappingURL=Router.js.map
