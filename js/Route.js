// Generated by CoffeeScript 2.2.4
var PathMatcher, Route, RouteConfig, assertValid, isValid, noop, sliceArray, validateBody, valido;

PathMatcher = require('./PathMatcher');

assertValid = require('assertValid');

sliceArray = require('sliceArray');

isValid = require('isValid');

valido = require('valido');

noop = require('noop');

RouteConfig = valido({
  verb: 'string|regexp'
});

Route = class Route {
  constructor(config) {
    assertValid(config, RouteConfig);
    this._verb = new RegExp('^(' + config.verb + ')$');
    this._matcher = noop.true;
    this._responder = null;
    this;
  }

  query(arg) {
    if (arguments.length > 1) {
      arg = sliceArray(arguments);
    }
    if (this._queryType !== void 0) {
      throw Error('Cannot call `query` more than once per route');
    }
    this._queryType = valido(arg);
    this._queryType.strict = true;
  }

  body(arg) {
    if (arguments.length > 1) {
      arg = sliceArray(arguments);
    }
    if (this._body !== void 0) {
      throw Error('Cannot call `body` more than once per route');
    }
    this._body = arg;
    // Passing `true` means the body must exist, but can be any type.
    if (arg !== true) {
      this._bodyType = validateBody(arg);
      // Shapes cannot have unknown properties.
      if (isValid(arg, 'object')) {
        this._bodyType.strict = true;
      }
    }
  }

  listen(responder) {
    if (this._responder) {
      if (Array.isArray(this._responder)) {
        this._responder.push(responder);
      } else {
        this._responder = [this._responder, responder];
      }
    } else {
      this._responder = responder;
    }
    return this;
  }

  match(path, responder) {
    if (this._matcher !== noop.true) {
      throw Error('The matcher is already set');
    }
    if (typeof path === 'function') {
      this._matcher = path;
    } else {
      this._matcher = PathMatcher.create(path);
      this._path = typeof path === 'string' ? path : path.source;
    }
    if (responder) {
      this.listen(responder);
    }
    return this;
  }

  _match(req, path) {
    if (this._verb.test(req.method)) {
      return this._matcher(req, path);
    }
  }

  async _exec(req, res) {
    var fn, i, len, oops, ref, val;
    if (oops = this._validateQuery(req.query)) {
      return {
        error: oops('query')
      };
    }
    if (this._body && !req.body) {
      // Read the body.
      req.body = (await req.readBody({
        json: this._body === 'object' || isValid(this._body, 'object')
      }));
      if (req.body === null) {
        return {
          error: 'Missing body'
        };
      }
      // Validate the body.
      if (this._bodyType) {
        if (this._bodyType.name === 'string') {
          req.body = req.body.toString();
        } else if (oops = this._bodyType.assert(req.body)) {
          return {
            error: oops('body')
          };
        }
      }
    }
    if (Array.isArray(this._responder)) {
      ref = this._responder;
      for (i = 0, len = ref.length; i < len; i++) {
        fn = ref[i];
        if (val = (await fn(req, res))) {
          return val;
        }
      }
    } else if (fn = this._responder) {
      if (val = (await fn(req, res))) {
        return val;
      }
    }
  }

  _validateQuery(query) {
    var type;
    if (type = this._queryType) {
      return type.assert(query);
    }
  }

};

module.exports = Route;

validateBody = function(type) {
  if (valido.is(type)) {
    return type;
  }
  if (isValid(type, 'object|array|function')) {
    return valido(type);
  }
  if (isValid(type, 'string')) {
    return valido.get(type);
  }
};

//# sourceMappingURL=Route.js.map
